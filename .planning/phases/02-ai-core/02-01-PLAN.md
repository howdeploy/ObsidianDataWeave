---
phase: 02-ai-core
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - SKILL.md
autonomous: true
requirements:
  - DOCX-04
  - DOCX-05
  - META-01
  - META-02
  - META-03
  - META-04
  - LINK-01
  - LINK-02

must_haves:
  truths:
    - "SKILL.md contains step-by-step processing instructions that Claude can follow to atomize a parsed JSON document"
    - "Instructions specify two-pass wikilink generation: title enumeration first, body generation with links second"
    - "Tag assignment instructions reference tags.yaml taxonomy and require 2-5 tags per note"
    - "Frontmatter schema in SKILL.md matches locked v1 fields: tags, date, source_doc, note_type"
    - "Output schema section defines the exact atom plan JSON structure Phase 3 will consume"
  artifacts:
    - path: "SKILL.md"
      provides: "Claude operating instructions for document atomization"
      contains: "ObsidianDataWeave"
  key_links:
    - from: "SKILL.md"
      to: "rules/atomization.md"
      via: "Processing rules referenced in SKILL.md context assembly"
      pattern: "atomization"
    - from: "SKILL.md"
      to: "rules/taxonomy.md"
      via: "Tag and wikilink rules referenced in SKILL.md context assembly"
      pattern: "taxonomy"
    - from: "SKILL.md"
      to: "tags.yaml"
      via: "Tag list injected at runtime by atomize.py"
      pattern: "tags.yaml"
---

<objective>
Create SKILL.md — the Claude operating instruction file that defines how to process a parsed JSON document into an atom plan. This is the core intellectual artifact of Phase 2: the prompt that turns raw parsed content into structured atomic notes with tags, wikilinks, and MOC hints.

Purpose: SKILL.md is the "brain" of ObsidianDataWeave. It encodes all atomization logic, tag inference, wikilink generation, and output schema into instructions Claude follows at processing time. Without SKILL.md, there is no AI core.

Output: SKILL.md file at project root (~600-800 words), containing input format description, processing steps (title enumeration, body generation, wikilink pass, tag assignment, MOC generation, JSON output), output schema, and a worked few-shot example.
</objective>

<execution_context>
@/home/kosya/.claude/get-shit-done/workflows/execute-plan.md
@/home/kosya/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ai-core/02-CONTEXT.md
@.planning/phases/02-ai-core/02-RESEARCH.md
@rules/atomization.md
@rules/taxonomy.md
@tags.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SKILL.md with atomization prompt and processing steps</name>
  <files>SKILL.md</files>
  <action>
Create SKILL.md at project root. This file is read by Claude as operating instructions — it is NOT a script. Keep it under 800 words. Structure:

1. **Header**: "# ObsidianDataWeave Atomization Skill" — one-line purpose statement: "You receive a parsed document (JSON) and produce a complete atom plan (JSON)."

2. **Input Format section**: Describe the parsed JSON schema from parse_docx.py output:
   - `source_file`: string (original .docx filename)
   - `heading_depth_offset`: integer
   - `sections`: array of `{heading, level, paragraphs}`
   Note: sections[0] may have `heading: null` (pre-heading content).

3. **Processing Steps section** (the core — this is the multi-pass strategy):

   **Step 1: Title Enumeration Pass**
   For each section in parsed JSON:
   - Estimate final note length: source_words x 1.3 (expansion factor for context-adding)
   - If estimated > 600 words or section contains 2+ distinct ideas: split into multiple notes with separate titles
   - If estimated < 150 words: note will need Claude to add substantial context/connective tissue
   - Output: complete list of all proposed note titles (noun-phrase style per rules/atomization.md)
   - DO NOT write note bodies yet

   **Step 2: Note Body Generation**
   For each title from Step 1:
   - Write body in the source document's language (Russian doc -> Russian notes, English doc -> English notes) per user decision
   - 150-600 words per note
   - Hybrid approach per user decision: preserve original phrases/formulations but add introductory context and connective tissue so each note is self-contained
   - DO NOT insert wikilinks yet — write plain text bodies

   **Step 3: Wikilink Insertion Pass**
   Review all note bodies against the confirmed title list from Step 1:
   - Insert [[Title]] for explicit title mentions in text
   - Insert [[Title]] for semantically related concepts (even if title not literally mentioned) per LINK-02
   - Place wikilinks inline in text only — NO separate "Related notes" section at bottom (per user decision)
   - Target: 3-7 wikilinks per note. Links MUST reference titles from Step 1 ONLY.
   - Instruction: "Use EXACTLY these titles — do not rephrase: [list]"

   **Step 4: Tag Assignment**
   For each note, select 2-5 tags from the provided tag list (injected at runtime from tags.yaml).
   - Prefer specific over generic (tech/llm over tech/ai when appropriate)
   - If NO tag fits: use the closest available tag AND add an entry to proposed_new_tags with format `{tag: "domain/subtag", reason: "why needed"}`
   - Determine note_type: "atomic" (default), "moc" (one per document, generated in Step 5), "source" (when note describes a product/book/tool)

   **Step 5: MOC Generation** (ALWAYS LAST — after all atomic notes confirmed)
   Generate exactly one MOC note:
   - Title: cleaned source document name (remove file extension, truncate at 60 chars if needed) + " — MOC"
   - Body: two-level hierarchy mirroring source document headings
     - Level 1 sections become H2 headers in MOC
     - Notes from each section listed as [[wikilinks]] under their parent heading
   - note_type: "moc", tags: document's primary domain tags
   - MOC is navigational only — no analysis, no new content

   **Step 6: JSON Output**
   Output the complete atom plan as a single JSON object. Output ONLY valid JSON, no prose, no markdown code fences.

4. **Output Schema section**: Define the exact JSON structure:
   ```
   {schema_version: "1", source_file, processed_date, notes: [{id, title, note_type, tags, source_doc, date, body, proposed_new_tags}], proposed_tags}
   ```
   Field definitions:
   - id: "note-001" through "note-NNN", "moc-001" for MOC
   - title: exact note filename (without .md); MUST match [[wikilink]] targets exactly
   - note_type: "atomic" | "moc" | "source"
   - tags: list of 2-5 strings from tags.yaml in domain/subtag format
   - source_doc: verbatim .docx filename
   - date: ISO 8601 processing date
   - body: complete note body in markdown with [[wikilinks]] inline
   - proposed_new_tags: list of {tag, reason} for tags not in tags.yaml

5. **Critical Constraints section** (guardrails):
   - "Tags MUST come from the provided tag list ONLY. If none fit, use closest match AND add proposed_new_tag."
   - "Wikilink targets MUST match titles from Step 1 exactly. Do not rephrase or paraphrase titles in links."
   - "Every note MUST be self-contained — a reader unfamiliar with the source document must understand it fully."
   - "MOC is generated LAST, after all atomic note titles are finalized."
   - "Do not add YAML frontmatter in the body field — frontmatter fields are separate JSON fields."

Do NOT embed tags.yaml content or rules file content directly in SKILL.md — atomize.py will inject those at runtime to keep SKILL.md version-stable.
  </action>
  <verify>
Run these checks:
1. `test -f SKILL.md` — file exists at project root
2. `wc -w SKILL.md` — under 800 words
3. Verify SKILL.md contains all 6 processing steps: grep for "Step 1", "Step 2", "Step 3", "Step 4", "Step 5", "Step 6"
4. Verify output schema section mentions all required fields: grep for "schema_version", "source_file", "processed_date", "notes", "note_type", "tags", "source_doc", "body", "proposed_new_tags"
5. Verify guardrails section exists: grep for "MUST" (should appear 3+ times for constraints)
6. Verify no embedded tags.yaml content (should NOT contain actual tag values like "tech/ai" or "productivity/pkm" — those are injected at runtime)
  </verify>
  <done>SKILL.md exists at project root, is under 800 words, contains 6 sequential processing steps (title enumeration, body generation, wikilink insertion, tag assignment, MOC generation, JSON output), defines the atom plan JSON output schema with all required fields, includes critical constraints as guardrails, and does NOT embed tags.yaml content (keeping it runtime-injectable).</done>
</task>

<task type="auto">
  <name>Task 2: Add few-shot example to SKILL.md</name>
  <files>SKILL.md</files>
  <action>
Append a "## Few-Shot Example" section to SKILL.md. This section provides one complete worked example showing how a parsed JSON input section becomes atom plan JSON output. Use Russian content (matching the reference documents) to demonstrate the pipeline.

The example should show:
1. **Input**: A small parsed JSON section (use a simplified version of a Smart Connections section — ~100 words, level 2, 3-4 paragraphs)
2. **Output**: The corresponding atom plan JSON entry showing:
   - id: "note-001"
   - title: noun-phrase in Russian
   - note_type: "atomic"
   - tags: 2-3 tags from the actual tags.yaml taxonomy (use real tag paths like "tech/ai", "productivity/obsidian")
   - source_doc: "Smart Connections: Интеллектуальный мозг вашей базы Obsidian.docx"
   - date: "2026-02-26"
   - body: ~170 words in Russian with 2 inline [[wikilinks]] referencing plausible note titles
   - proposed_new_tags: [] (clean example)

Keep the example concise — it demonstrates format, not exhaustive coverage. The input section should be SHORT (3-5 lines of JSON) so the example does not bloat SKILL.md.

After adding the example, verify total SKILL.md word count is still under 900 words (800 instructions + ~100 example). If over, trim the example body to stay within budget.

Important: The example wikilink targets (e.g., [[Атомарность заметок Zettelkasten]]) should be plausible titles that COULD appear in the same processing run — they demonstrate the linking pattern.
  </action>
  <verify>
1. `grep -c "Few-Shot Example" SKILL.md` — returns 1
2. `grep "note-001" SKILL.md` — example contains a note entry
3. `grep "\[\[" SKILL.md` — example contains wikilinks
4. `grep "proposed_new_tags" SKILL.md` — example shows the field
5. `wc -w SKILL.md` — total under 900 words
  </verify>
  <done>SKILL.md contains a complete few-shot example section showing input (parsed JSON section) mapped to output (atom plan JSON entry) with Russian content, real tags from tags.yaml taxonomy, inline wikilinks, and all required JSON fields. Total file size remains under 900 words.</done>
</task>

</tasks>

<verification>
1. SKILL.md exists at project root and is readable
2. SKILL.md word count is under 900 words (instructions + example)
3. All 6 processing steps are present and in correct order
4. Output schema defines all atom plan JSON fields
5. Few-shot example uses real tags.yaml tag paths
6. Wikilinks in example use [[Title]] syntax
7. No tags.yaml content or rules content embedded (runtime injection only)
8. SKILL.md references the hybrid text handling approach (preserve original + add context) per user decision
9. Language instruction is present (write in source document's language) per user decision
10. Inline-only wikilink placement is specified (no "Related notes" section) per user decision
</verification>

<success_criteria>
- SKILL.md is a complete, self-contained instruction file that another Claude instance could follow without clarification
- Processing steps cover the full pipeline: analyze -> title -> body -> link -> tag -> MOC -> JSON
- Two-pass wikilink strategy is explicit (titles first, then links referencing those exact titles)
- Output schema matches the contract Phase 3 will consume
- All 8 requirements (DOCX-04, DOCX-05, META-01, META-02, META-03, META-04, LINK-01, LINK-02) are addressed in the processing steps
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-core/02-01-SUMMARY.md`
</output>
